# <strong>2.2 链表</strong>
<hr>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存空间是所有程序的公共资源,在一个复杂的系统运行环境下,空闲的内存空间可能散落在内存各处.我们知道,存储数组的内存空间必须是连续的,而当数组非常大时,内存可能无法提供如此大的连续空间.此时链表的灵活性优势就体现出来了.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="text-decoration:underline"> 链表(linked list) </strong>是一种线性数据结构,其中的每个元素都是一个节点对象,各个节点通过“引用”相连接.引用记录了下一个节点的内存地址,通过它可以从当前节点访问到下一个节点.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。</p>

<figure markdown="span">
  ![链表定义与存储方式](../pic/2/linklist-definition.png)
  <figcaption>图2-2-1 链表定义与存储方式</figcaption>
</figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察图2-2-1,链表的组成单位是<strong style="text-decoration:underline">节点（node）</strong>对象.每个节点都包含两项数据:</p>

* data: 数据域,也是节点的值
* next: 指针域,指向下一个节点的指针


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如以下代码所示，链表节点 <code>ListNodec</code> 除了包含值,还需额外保存一个引用（指针）.因此在相同数据量下,<strong style="color:hotpink">链表比数组占用更多的内存空间</strong> .

=== "C"

    ```c linenums="1"
    /* 链表节点结构体 */
    typedef struct ListNode {
        int val;               // 节点值
        struct ListNode *next; // 指向下一节点的指针
    } ListNode;

    /* 构造函数 */
    ListNode *newListNode(int val) {
        ListNode *node;
        node = (ListNode *) malloc(sizeof(ListNode));
        node->val = val;
        node->next = NULL;
        return node;
    }
    ```


=== "C++"

    ```cpp linenums="1"
    /* 链表节点结构体 */
    struct ListNode {
        int val;         // 节点值
        ListNode *next;  // 指向下一节点的指针
        ListNode(int x) : val(x), next(nullptr) {}  // 构造函数
    };
    ```

=== "Python"

    ```python linenums="1"
    class ListNode:
    """链表节点类"""
    def __init__(self, val: int):
        self.val: int = val               # 节点值
        self.next: ListNode | None = None # 指向下一节点的引用
    ```

=== "Java"

    ```java linenums="1"
    /* 链表节点类 */
    class ListNode {
        int val;        // 节点值
        ListNode next;  // 指向下一节点的引用
        ListNode(int x) { val = x; }  // 构造函数
    }
    ```

## <strong>链表中的一些概念</strong>
### 头节点

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单链表的开始结点之前设立一个节点称之为<code style="color: #00c853">头结点</code>(也称为哨兵节点或哑节点),头结点的数据域可以不存储任何信息,也可以存储<strong>链表的长度</strong>等附加信息,头结点的指针域存储指向第一个结点(首元结点)的指针。</p>

<figure markdown="span">
  ![带头节点和不带头结点区别](../pic/2/head-nohead.png)
  <figcaption>图2-2-1 带头节点和不带头结点区别</figcaption>
</figure>

### 头指针
<p>头指针是指链表中,<strong>指向</strong>第一个结点的指针.</p>
<p>头指针具有标识作用,所以常常会用头指针冠以链表的名字.所以你定义一个链表,那么链表的名字一般就是这个链表的头指针.</p>
<p><code style="color: #c3185d">ListNode L = new ListNode(0); </code>左边的是指针和结点</p>
<p>无论链表是否为空,头指针均不为空,头指针是链表的必要元素.</p>

<figure markdown="span">
  ![带头节点和不带头结点区别](../pic/2/headPointer.png)
  <figcaption>图2-2-2 带头节点和不带头结点区别</figcaption>
</figure>

!!! info "整理成一句话就是"

    * <strong style="color:red">头指针:</strong> 指向第一个节点
    * <strong style="color:red">头节点:</strong> 在首元结点前面设立的一个结点
    * <strong style="color:red">首元结点:</strong> 链表中第一个元素所在的结点
    * <strong style="color:red">元素结点:</strong> 存储链表实际信息的结点

<hr>

<p>下一节以带头节点的单链表为例展示以下6种函数的实现</p>
* 头插法创建链表
* 尾插法创建链表
* 按值查找节点
* 按位序插入节点
* 按位序删除节点











